# 🧠 Hardware-Accelerated Dot Product Engine (IEEE-754 Float)

This project implements a **hardware dot product accelerator** using IEEE-754 32-bit floating-point arithmetic in **pure Verilog**, with a fully automated **testbench and software verification pipeline**.

It supports:
- ✅ Configurable vector lengths
- ✅ 32-bit float inputs (patch and filter)
- ✅ MAC accumulation using a pipelined Verilog core
- ✅ Functional correctness validation via Python

---

## 🚀 What This Project Does

This Verilog design computes the dot product:

```
result = ∑ patch[i] * filter[i]
```

- Inputs and output are in 32-bit IEEE-754 float format
- Internal multiplication and accumulation are handled by a hardware MAC unit
- A testbench generates randomized inputs and logs the output
- A Python script parses these logs and compares them against a golden software model

---

## 📂 Project Structure

### `DotProductEngine.v`

Main dot product module.

- Inputs: `start`, `vec_length`, `patch_data`, `filter_data`
- Outputs: `result`, `done`, `patch_addr`, `filter_addr`
- FSM-controlled accumulation
- Interfaces with a floating-point MAC unit

### `MAC32_top.v`

This is a topmodule of Verilog MAC (Multiply-Accumulate) unit which performs following operation:
```verilog
result <= a + (b * c);
```

- Accepts 32-bit IEEE-754 floats as input
- Optional output register for pipelining
- Can be easily replaced with an FPU core in the future

#### Details of this MAC unit can be found in the following repository -
[GitHub repo](https://github.com/A-m-e-y/Floating_Point_MAC_HW_Accelerator)

### `tb_DotProductEngine.v`

A complete testbench that:
- Generates randomized IEEE-754 inputs using a custom float generator
- Drives the engine with varying vector lengths
- Logs all inputs and DUT outputs to a file (`dot_product_vectors.txt`)
- Dumps waveform via `$dumpfile` for GTKWave or other viewers

It supports two methods for generating 32-bit float test data:
1. ✅ Predefined float table (e.g., `1.0`, `-1.5`, `4.7`, ...)
2. ✅ `random_float32()` — a function that generates safe, valid random IEEE-754 32-bit floats with randomized sign, exponent, and mantissa

---

## 📆 Example Random Float Generator

```verilog
function [31:0] random_float32;
    input dummy;
    reg [7:0] exponent;
    reg [22:0] mantissa;
    reg sign;
begin
    exponent = $urandom_range(120, 140);              // Safe exponent range
    mantissa = $urandom_range(0, (1<<23) - 1);        // 23-bit mantissa
    sign     = $urandom_range(0, 1);                  // Random sign bit
    random_float32 = {sign, exponent, mantissa}; // Assembled float
end
endfunction
```

Call like:
```verilog
patch_mem[i]  = random_float32(0);
filter_mem[i] = random_float32(0);
```

---

## 📄 `dot_product_vectors.txt`

Log file generated by the testbench. For each test case, it stores:

```
vector_length: N
<patch_0_hex> <filter_0_hex>
<patch_1_hex> <filter_1_hex>
...
DUT: <result_hex>
```

This file is used for Python-based validation.

---

## 💻 `verify_dot_product.py`

A Python script that:
- Parses `dot_product_vectors.txt`
- Converts hex values to floats
- Computes software reference result
- Compares it to DUT output
- Prints detailed calculation breakdown

### 🔍 Example Output

```
=== Test 3 ===
Vector Length: 4
patch = 2.000000, filter = -1.000000 → product = -2.000000
patch = 3.000000, filter = 2.000000 → product = 6.000000
...

[Software Result]  : 12.000000
[DUT Result]       : 12.000000
[RESULT] ✅ PASS
```

### 📟 Final Summary

```
--- Scoreboard ---
Total Tests : 10
Passed      : 10
Failed      : 0
------------------
```

---

## 📈 Waveform Debugging

Waveform output (`tb_DotProductEngine.vcd`) can be opened in **GTKWave** or other tools. Key signals include:
- `clk`, `rst_n`, `start`, `done`
- `patch_data`, `filter_data`, `result`
- `patch_addr`, `filter_addr`
- `mac_result`, `acc`

---

## 🛠️ How to Run

### Step 1: Simulate the Testbench

Use your Verilog simulator (e.g., `iverilog`, `VCS`, `ModelSim`):

```bash
iverilog -o sim tb_DotProductEngine.v DotProductEngine.v MAC_Unit.v
vvp sim
```

### Step 2: View Waveform

```bash
gtkwave tb_DotProductEngine.vcd
```

### Step 3: Run Python Validator

```bash
python3 verify_dot_product.py
```

---

## 📚 Dependencies

- **Verilog simulator**: iverilog / ModelSim / VCS
- **Waveform viewer**: GTKWave
- **Python 3.x**:
  - No external libraries required (only `struct`)

---
